一 ：make的递归执行 make -c
	make 的递归过程指的是:在 Makefile 中使用“make”作为一个命令来执行本身
	或者其它 makefile 文件的过程。递归调用在一个存在有多级子目录的项目中非常有用。
	例如,当前目录下存在一个“subdir”子目录,在这个子目录中有描述此目录编译规则
	的 makefile 文件,在执行 make 时需要从上层目录(当前目录)开始并完成它所有子
	目录的编译。那么在当前目录下可以使用这样一个规则来实现对这个子目录的编译:
		subsystem:
		cd subdir && $(MAKE)  第一个规则命令的意思是:进入子目录,然后在子目录下执行make。
	其等价于规则:
		subsystem:
		$(MAKE) -C subdir
	
	第二个规则使用了make的“-C”选项,同样是首先进入子目录而后再执行make。
	上层make(在当前目录下运行的make进程)和下层make(subdir目录下运行的make进程)之间存在的联系。也许会发现这两个规则的实现,使用伪目标更能提高效率
	。
	在 make 的递归调用中,需要了解一下变量“CURDIR”,此变量代表 make 的工
	作目录。当使用“-C”选项进入一个子目录后,此变量将被重新赋值。总之,如果在
	Makefile 中没有对此变量进行显式的赋值操作,那么它代表 make 的工作目录。我们也
	可以在 Makefile 为这个变量赋一个新的值。此时这变量将不再代表 make 的工作目录。

二：变量MAKE  $(MAKE)”是对变量“MAKE”的引用
	在使用 make 的递归调用时,在 Makefile 规则的命令行中应该使用变量“MAKE”来代替直接使用“make”

	subsystem:
	cd subdir && $(MAKE)
	变量“MAKE”的值是“make”。如果其值为“/bin/make”那么上边规则的命令就为
	“cd subdir && /bin/make”。这样做的好处是:当我们使用一个其它版本的 make 程序
	时,可以保证最上层使用的 make 程序和其子目录下执行的 make 程序保持一致。

	另外使用此变量的另外一个特点是:
	当规则命令行中变量MAKE时,
	可以改变make的“-t”(“--touch”,)“-n”(“--just-print”)和“-q”(“--question”)命令行选项的
	效果。它所实现的功能和在规则中命令行首使用字符“+”的效果相同
	。
	在规则的命令行中使用“make”代替了“$(MAKE)”以后,上例子规则的命令行
	为:“cd subdir && make”。在我们执行“make -t”(“-t”选项用来更新所有目标的时
	间戳,而不执行任何规则的命令,)
	,结果是仅仅创
	建一个名为“subsystem”的文件,而不会进入到目录“subdir”去更新此目录下文件
	的时间戳。我们使用“-t”命令行参数的初衷是对规则中的目标文件的时间戳进行更新。
	而如果使“cd subdir && $(MAKE)”作为规则的命令行,执行“make -t”就可以实现
	我们的初衷。
	变量“MAKE”的这个特点是:在规则的命令行中如果使用变量“MAKE”
	,标志“-t”“-n”和“-q”在这个命令的执行中不起作用。尽管这些选项是告诉 make 不执
	行规则的命令行,但包含变量“MAKE”的命令行除外,它们会被正常执行。同时,执
	行 make 的命令行选项参数被通过一个变量“MAKEFLAGS”传递给子目录下的 make
	程序。
	例如,当使用 make 的命令行选项“-t”来更新目标的时间戳或者“-n”选项打印
	命令时,
	这些选项将会被赋值给变量
	“MAKEFLAGS”
	被传递到下一级的 make 程序中。
	在下一级子目录中执行的 make,这些选项会被附加作为 make 的命令行参数来执行,
	和在此目录下使用“make -t”或者“make -n”有相同的效果。

